# Owner side is always child, shouldn't propogate changes to parent (no CascadeType.ALL).
# Everything is FetchType.EAGER because it will definitely work that way in code; for efficiency, can optimize later by removing eager fetch type.
# Many of the annotations are not needed as they are the default behavior. They are added anyway to facilitate changing the values from defaults if desired.

# %0:Entity class of referencing Type, located in owning entity.
# %1:referencing type isntance variable, located in owning entity.
# %pk:primary key variable of referencing Type.
# %1_%pk: sql case
# %3_%opk: sql case, the primary key other than the %pk one.
# #2:Entity class of owning Type, located in referencing entity.
# #3:owning type isntance variable, located in referencing entity.

one2one_owner=    @OneToOne( fetch = FetchType.EAGER )^    @JoinColumn( name = "%1_%pk", referencedColumnName = "%pk" )^    private %0 %1;
one2one_referencing=    @OneToOne( mappedBy = "%1", fetch = FetchType.EAGER, cascade = CascadeType.ALL, orphanRemoval = true )^    private %2 %3;

# many to one is the 'many' side, always the owner
many2one=    @ManyToOne( fetch = FetchType.EAGER )^    @JoinColumn( name = "%1_%pk", referencedColumnName = "%pk" )^    private %0 %1;
# one to many is the 'one' side, always referencing
one2many=    @OneToMany( mappedBy="%1", fetch = FetchType.EAGER, cascade = CascadeType.ALL, orphanRemoval = true )^    private Set<%2> %3;

# eager or cascade are not advised here as the relationship connections are too great.
many2many_owner=    @ManyToMany^    @JoinTable( ^      name="%1__%3", ^      joinColumns = @JoinColumn( name = "%3_%opk" ), ^      inverseJoinColumns = @JoinColumn( name = "%1_%pk" ) )^    private Set<%0> %1;
# many2many_owner=    @ManyToMany^    @JoinTable( name="%1__%3" )^    private Set<%0> %1;

many2many_referencing=    @ManyToMany(mappedBy = "%1")^    private Set<%2> %3;



